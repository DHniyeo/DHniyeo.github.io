

> 올해 2월부터 5월까지 Ele.me에 컨설턴트로 합류하여 PWA 관련 업무에 참여하게 된 것을 영광으로 생각합니다. 이 기사는 원래 영어로 작성되었으며 매체에 게시되었습니다. [Ele.me를 Progressive Web Apps로 업그레이드](https://medium.com/elemefe/upgrading-ele-me-to-progressive-web-app-2a446832e509)，주목을 받았습니다. 그래서 저도 중국어판으로 다시 작성해서 공유하기로 했는데요, 도움이 되셨으면 합니다 ;) <br><br>
> 이 기사는 [CSDN](http://geek.csdn.net/news/detail/210535) [Ele.me Front-End - Knowing Column](https://zhuanlan.zhihu.com/ElemeFE), [Hux Blog] "Programmer" 2017년 7월호와 동시 게재(https://huangxuan.me)，재인쇄를 위해 링크를 보관하십시오.


Vue.js [공개][1] 공식 트위터 이후 처음으로 [엘레미 모바일 웹사이트](https://h5.ele.me/msite/#pwa= true)를 진행하고 있습니다. [Progressive Web App][2]에서 작동하도록 업그레이드하십시오. 최근 Google I/O 2017 [staged] (https://m.weibo.cn/status/4109332495285652)에서 마침내 종료되었습니다. 국내 사용자만을 위한 세계 최초의 PWA를 출시하게 되어 영광이지만, 국내 웹 및 브라우저 생태계의 발전을 위해 구글, UC, 텐센트와 협력하게 되어 더욱 영광입니다.

## 다중 페이지 애플리케이션, Vue, PWA?

네이티브 애플리케이션 수준 경험을 달성하기 위해 PWA를 구축하기 위해 커뮤니티의 현재 주류 관행은 SPA, 즉 단일 페이지 애플리케이션 모델(Single-page App)을 사용하여 전체 웹 애플리케이션을 구성하는 것입니다. 업계에서 가장 유명한 PWA 사례 [Twitter Lite][3], [Flipkart Lite][4], [Housing Go][5] 및 [Polymer Shop][6]도 예외 없이 사용됩니다.

그러나 Ele.me는 많은 국내 전자 상거래 웹 사이트와 마찬가지로 다중 페이지 응용 프로그램 모델(MPA, Multi-page App)이 가져오는 이점 중 일부를 선호하므로 이동국을 Angular.js 기반에서 변경했습니다. 1년 이상에 한 번 단일 페이지 애플리케이션이 현재의 다중 페이지 애플리케이션 모델로 리팩토링됩니다. 팀의 가장 중요한 이점은 페이지 간의 격리 및 분리로 각 페이지를 독립적인 "마이크로 서비스"로 취급할 수 있으며 이러한 서비스는 독립적으로 반복되어 다양한 제3자에게 제공될 수 있습니다. 심지어 다른 팀에서 독립적으로 유지 관리합니다. 그리고 전체 웹 사이트는 거대한 전체가 아니라 다양한 서비스의 모음입니다.

 
동시에 우리는 여전히 [Vue.js](http://vuejs.org/)를 JavaScript 프레임워크로 사용합니다. React/Angular와 같은 "중무기"의 경쟁자일 뿐만 아니라 Vue의 경량 및 고성능 이점으로 인해 기존의 다중 페이지 애플리케이션 개발에서 인기 있는 "jQuery/Zepto/Kissy + 템플릿 엔진" 기술 스택이 되었습니다. 대리자. Vue에서 제공하는 컴포넌트 시스템, 선언적 및 반응형 프로그래밍은 코드 구성, 공유, 데이터 흐름 제어, 렌더링 및 기타 측면의 개발 효율성을 향상시켰습니다. [Vue도 프로그레시브 프레임워크입니다]((https://www.youtube.com/watch?v=pBBSp_iIiVM)) 웹 사이트의 복잡성이 계속 증가하면 Vuex 또는 Vue-Router를 요청에 따라 점진적으로 도입할 수 있습니다. 모듈. 언젠가 다시 한 페이지로 바꾸고 싶다면? (누가 알아...)

2017년에 PWA는 웹 애플리케이션의 새로운 물결이 되었습니다. 우리는 기존 "Vue + 다중 페이지" 아키텍처로 PWA를 업그레이드하는 길과 어떤 효과를 얻을 수 있는지 확인하기로 결정했습니다.


## "PRPL" 패턴 구현

["PRPL"][7]("보라색"으로 발음)은 최신 웹 플랫폼의 신기술을 활용하여 모바일 웹의 성능과 경험을 크게 최적화하는 것을 목표로 하는 Google 엔지니어가 제안한 웹 애플리케이션 아키텍처 패턴입니다. 고성능 PWA 시스템 설계는 높은 수준의 추상화를 제공합니다. 웹 애플리케이션을 처음부터 리팩토링하지는 않겠지만 마이그레이션 목표로 "PRPL" 패턴을 구현할 수 있습니다. "PRPL"은 실제로 Push/Preload, Render, Precache, Lazy-Load의 약어이며 아래에서 구체적인 의미를 확장합니다.


### 1. PUSH/PRELOAD, 초기 URL 라우팅에 필요한 키 리소스를 푸시/프리로드합니다.

HTTP2 Server Push이든 `<link rel="preload">`이든 간에 핵심은 HTTP 왕복, 브라우저 구문 분석을 저장하기 위해 애플리케이션 종속성 그래프(Dependency Graph)에 숨겨진 일부 리소스를 미리 요청하려는 것입니다. 문서 또는 스크립트가 실행된 시간입니다. 예를 들어 경로 기반 코드 분할 SPA의 경우 초기 URL, 즉 사용자가 항목 URL 경로에 액세스하는 코드를 사용할 수 있다면 웹팩 매니페스트, 라우팅 및 기타 항목 청크가 다운로드되어 실행되기 전에 실행됩니다. 서버 푸시 또는 사전 로드를 위한 `<link rel="preload">`. 그런 다음 이러한 리소스가 실제로 요청되면 이미 다운로드되어 캐시에 저장될 수 있으므로 초기 경로에 대한 모든 종속성의 준비 속도가 빨라집니다.

다중 페이지 응용 프로그램에서 각 경로는 이 경로에 필요한 리소스만 요청하며 종속성은 일반적으로 단순합니다. Ele.me 이동국의 스크립트 종속성은 대부분 일반적인 `<script>` 요소이므로 브라우저의 프리로더에서 스캔하여 문서 파싱의 초기 단계에서 요청할 수 있습니다. 실제로 효과는 명시적 `< link rel="preload">`는 일관성이 있습니다.

![](/img/in-post/post-eleme-pwa/PUSH-link-rel-preload.jpg)

또한 HTTP2에서 가져온 멀티플렉싱을 더 잘 활용하기 위해 동일한 도메인 이름으로 모든 주요 정적 리소스를 제공합니다(더 이상 도메인 이름 해싱을 수행하지 않음). 동시에 API용 Server Push [실험](https://zhuanlan.zhihu.com/p/26757514)도 진행하고 있습니다.



### 2. RENDER, 초기 경로를 렌더링하고 가능한 한 빨리 응용 프로그램을 대화형으로 만듭니다.

이제 초기 경로의 모든 종속성이 준비되었으므로 가능한 한 빨리 초기 경로 렌더링을 시작할 수 있습니다. 이는 첫 번째 렌더링 시간, 대화식 시간 등과 같은 애플리케이션 메트릭을 개선하는 데 도움이 됩니다. 다중 페이지 애플리케이션은 JavaScript 기반 라우팅을 사용하지 않지만 기존 HTML 점프 메커니즘을 사용하므로 이 부분에서 다중 페이지 애플리케이션은 추가 작업을 수행할 필요가 없습니다.


### 3. PRE-CACHE, Service Worker를 사용하여 나머지 경로를 사전 캐시

이 부분은 [서비스 워커][9]의 참여가 필요합니다. 서비스 워커는 브라우저와 네트워크 사이에 위치한 클라이언트 프록시입니다. 이를 통해 흐르는 HTTP 요청을 가로채서 처리하고 응답할 수 있으므로 개발자는 캐시의 웹 애플리케이션에 대한 리소스. 그러나 서비스 워커는 실제로 HTTP 요청을 시작하여 "백그라운드"에서 미래에 필요한 리소스를 미리 요청하고 미리 캐시할 수 있습니다.

![](/img/in-post/post-eleme-pwa/PRECACHE-future-routes.jpg)


우리는 이미 빌드 프로세스 동안 `.vue` 컴파일, 파일 이름 해싱 등에 [Webpack][10]을 사용하므로 "사전 캐시 매니페스트"에 캐시해야 하는 종속성을 수집하는 데 도움이 되는 웹팩 플러그인을 작성했습니다. , 이 매니페스트를 사용하여 모든 빌드에서 새 서비스 워커 파일을 생성합니다. 새로운 서비스 워커가 활성화되면 매니페스트의 리소스가 요청되고 캐시되며 이는 실제로 [SW-Precache 라이브러리][11]의 작동 메커니즘에 매우 가깝습니다.

**사실, 우리는 "중요한 경로"로 표시한 경로에 대해서만 의존성 수집을 수행합니다. **이 "핵심 경로"의 종속성을 전체 애플리케이션의 ["앱 셸"][12] 또는 "설치 패키지"로 이해할 수 있습니다. 모두 캐시되거나 성공적으로 설치되면 사용자가 온라인이든 오프라인이든 관계없이 캐시에서 직접 웹 애플리케이션을 시작할 수 있습니다. 그다지 중요하지 않은 경로의 경우 런타임에 증분 캐싱을 사용합니다. 우리가 사용하는 [SW-Toolbox][13]는 LRU 교체 전략과 TTL 무효화 메커니즘을 제공하여 애플리케이션이 브라우저의 캐시 할당량을 초과하지 않도록 합니다.

### 4. LAZY-LOAD 요청 시 지연 로드, 나머지 경로의 지연 인스턴스화

나머지 경로의 지연 로드 및 지연 인스턴스화는 SPA의 경우 비교적 성가신 일이므로 경로 기반 코드 분할 및 비동기 로딩을 구현해야 합니다. 운 좋게도 이것은 개별 경로가 본질적으로 분리되어 있는 다중 페이지 애플리케이션에서 다시 걱정할 필요가 없는 것입니다.

단일 페이지 또는 다중 페이지 응용 프로그램에 관계없이 이전 단계에서 이러한 경로의 리소스를 미리 다운로드하고 캐시했다면 지연 로드가 거의 즉각적이라는 점에 유의할 필요가 있습니다. 인스턴스화의 대가를 지불하십시오.

---


이 네 문장이 PRPL의 전부입니다. 흥미롭게도 우리는 다중 페이지 응용 프로그램에 PRPL을 구현하는 것이 단일 페이지 응용 프로그램보다 훨씬 쉽다는 것을 발견했습니다. 결과는 어떻게 되었습니까?

![](/img/in-post/post-eleme-pwa/Lighthouse-before.png)

Google에서 출시한 웹 성능 분석 도구인 Lighthouse(v1.6)에 따르면 시뮬레이션된 3G 네트워크에서 사용자의 초기 액세스(캐시 없음)는 약 2초 만에 "대화형"에 도달하여 매우 우수하다고 할 수 있습니다. . 재방문의 경우 모든 리소스는 Service Worker 캐시에서 직접 가져오기 때문에 페이지는 약 1초 만에 대화형 상태에 도달할 수 있습니다.

그러나 이야기는 그렇게 쉽게 끝나지 않습니다. 실제 경험에서 우리는 애플리케이션이 페이지에서 페이지로 전환할 때 여전히 매우 명백한 흰색 화면 간격이 있음을 발견했습니다.PWA가 전체 화면에서 실행되기 때문에 흰색 화면이 사용자 경험에 미치는 부정적인 영향은 내부보다 훨씬 더 큽니다. 브라우저. 이미 Service Worker로 모든 리소스를 캐시하지 않았습니까? 어떻게 그럴 수 있습니까?

![](/img/in-post/post-eleme-pwa/before-skeleton.jpg)
*홈페이지에서 디스커버리 페이지로 이동, 점프 진행 중 흰색 화면*



## 다중 페이지 애플리케이션의 함정: 다시 시작 오버헤드


SPA와 달리 다중 페이지 애플리케이션에서 라우팅 스위치는 기본 브라우저 문서 점프(문서 간 탐색)입니다. 즉, 이전 페이지는 완전히 삭제되고 브라우저는 다음 경로에 대해 모든 페이지를 다시 실행해야 합니다. 시작 단계: 리소스 재다운로드, HTML 재분석, JavaScript 재실행, 이미지 재디코드, 페이지 재레이아웃, 재페인트... 이러한 단계 중 많은 부분을 여러 경로에서 재사용할 수 있지만. 이러한 작업은 의심할 여지 없이 엄청난 계산 오버헤드를 생성하므로 상당한 시간 비용이 필요합니다.

그림은 2x CPU 스로틀링 시뮬레이션에서 시작 페이지(및 가장 무거운 페이지)에 대한 프로필 데이터를 보여줍니다. "대화형 시간"을 약 1초로 유지할 수 있다고 해도 사용자는 "단순히 탭 전환"을 하기에는 여전히 너무 느리다는 것을 알게 될 것입니다.

![](/img/in-post/post-eleme-pwa/msite-Before-Optim.png)

### 엄청난 자바스크립트 재시작 오버헤드

프로필에 따르면 첫 번째 페인트가 발생하기 전에 JavaScript 실행(스크립트 평가)에 상당한 시간(900ms)이 소요되는 것으로 나타났습니다. 거의 모든 스크립트는 파서 차단이지만 모든 UI는 JavaScript/Vue로 구동되기 때문에 성능 저하가 없습니다. 이 900ms의 약 절반은 Vue 런타임, 구성 요소, 라이브러리 등을 포함한 종속성을 실행하는 데 사용되고 나머지 절반은 비즈니스 구성 요소가 인스턴스화될 때 Vue 시작 및 렌더링에 사용됩니다. 소프트웨어 엔지니어링 관점에서 우리는 이러한 추상화가 필요하므로 오버헤드에 대해 JavaScript나 Vue를 비난하지 않습니다.

**그러나 SPA에서는 JavaScript의 시작 비용이 전체 수명 주기에 걸쳐 상각됩니다.** 각 스크립트는 한 번만 구문 분석 및 컴파일되어야 하며 Vue Large와 같이 Virtual DOM 생성과 같은 무거운 작업은 한 번만 수행할 수 있습니다. ViewModel 또는 Virtual DOM과 같은 객체도 재사용을 위해 메모리에 남길 수 있습니다. **불행히도 이것은 다중 페이지 응용 프로그램의 경우가 아니며 페이지를 전환할 때마다 JavaScript에 대해 막대한 재시작 비용을 지불합니다. **

### 브라우저 캐시, 도와주실 수 있나요?

할 수 있거나 할 수 없습니다.

V8은 컴파일된 기계어 코드를 로컬로 복사할 수 있는 [코드 캐싱](http://v8project.blogspot.com/2015/07/code-caching.html)을 제공하므로 요청, 파싱, 다음에 동일한 스크립트를 요청할 때 한 번에 모두 컴파일합니다. 또한 서비스 워커가 제공하는 캐시 저장소에 캐시된 스크립트의 경우 V8 코드 캐시가 첫 번째 실행 후에 트리거되어 다중 페이지 전환에 많은 도움을 줄 수 있습니다.

들어 본 적이 있는 또 다른 브라우저 캐시는 "정방향 및 역방향 캐시", Back-Forward Cache 또는 줄여서 bfcache입니다. 브라우저 제조업체는 이름을 다르게 지정합니다.


## 몇 가지 생각

### 다중 페이지 앱은 아직 갈 길이 멉니다

웹은 매우 다양한 플랫폼입니다. 정적 블로그에서 전자 상거래 웹 사이트, 데스크탑 생산성 소프트웨어에 이르기까지 모두 웹 제품군의 첫 번째 시민입니다. 그리고 우리가 웹 애플리케이션을 구성하는 방식 역시 다중 페이지, 단일 페이지, 범용 JavaScript 애플리케이션, WebGL 및 예측 가능한 웹 어셈블리와 같이 그 이상일 수 있습니다. 기술의 차이는 없으나 객관적으로 적용 가능한 시나리오의 차이는 존재한다.

[Jake](https://twitter.com/jaffathecake)는 [Chrome Dev Summit 2016](https://youtu.be/J2dOTKBoTL4?list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj)에서 "PWA !== SPA"라고 말했습니다. 그러나 우리가 일련의 최신 기술(PRPL, Service Worker, App Shell...)을 사용했음에도 불구하고 다중 페이지 애플리케이션 모델 자체의 단점으로 인해 여전히 극복할 수 없는 장애물이 있습니다. 다중 페이지 애플리케이션은 SPA와의 거리를 좁히기 위해 미래에 "bfcache API" 및 Navigation Transition과 같은 새로운 사양을 가질 수 있지만 오늘날 다중 페이지 애플리케이션의 한계도 매우 명백하다는 것을 인정해야 합니다.


### 그리고 PWA는 결국 웹 애플리케이션을 새로운 시대로 이끌 것입니다.

우리의 다중 페이지 응용 프로그램이 PWA를 업그레이드하는 과정에서 단일 페이지 응용 프로그램만큼 화려하지는 않지만 PWA 이면의 아이디어와 기술은 웹 플랫폼에서 더 나은 사용자 경험을 제공하는 데 실제로 도움이 됩니다.

PWA는 [차세대 웹 애플리케이션 모델](https://zhuanlan.zhihu.com/p/25167289)로서 웹 플랫폼 자체의 근본적인 문제인 네트워크 및 브라우저 UI에 대한 의존도가 높은 문제를 해결하려고 합니다. 따라서 모든 웹 응용 프로그램에서 이점을 얻을 수 있습니다. 다중 페이지 또는 단일 페이지, 데스크톱 또는 모바일 지향, React 또는 Vue가 중요하지 않습니다. 아마도 사용자가 모바일 웹에서 기대하는 바를 마침내 바꿀 것입니다. 이제 누가 데스크탑의 웹이 문서를 보기 위한 공간일 뿐이라고 생각합니까?

사용자가 웹을 우리만큼 사랑하게 하십시오.

---

마지막으로 Ele.me의 Wang Yisi, Ren Guanghui, Ti Ye, Google의 Michael Yeung, DevRel 팀, UC 브라우저 팀, Tencent X5 브라우저 팀이 이 프로젝트에 협력해 준 덕분입니다. 작성 과정에서 도움을 준 Yuxi You, Mengdi Chen, Jake Archibald에게 감사드립니다.



[1]: https://twitter.com/vuejs/status/834087199008239619
[2]: https://developers.google.com/web/progressive-web-apps/
[3]: https://blog.twitter.com/2017/how-we-built-twitter-lite
[4]: https://medium.com/progressive-web-apps/building-flipkart-lite-a-progressive-web-app-2c211e641883
[5]: https://medium.com/engineering-housing/progressing-mobile-web-fac3efb8b454
[6]: https://shop.polymer-project.org/
[7]: https://developers.google.com/web/fundamentals/performance/prpl-pattern/
[8]: https://calendar.perfplanet.com/2013/big-bad-preloader/
[9]: https://w3c.github.io/ServiceWorker/v1/
[10]: https://webpack.github.io/
[11]: https://medium.com/@Huxpro/how-does-sw-precache-works-2d99c3d3c725
[12]: https://developers.google.com/web/updates/2015/11/app-shell
[13]: https://googlechrome.github.io/sw-toolbox/


---
layout: post
date: 2024-04-10
title: "[BOJ-Code] 20058 - ë§ˆë²•ì‚¬ ìƒì–´ì™€ íŒŒì´ì–´ìŠ¤í†°"
tags: [Algorithm-êµ¬í˜„, Algorithm-DFS/BFS, Samsung-Coding]
categories: [Samsungê¸°ì¶œ, CodingTest]
---

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/20058)


> ğŸ’¡ ë„ˆë¹„ ìš°ì„  íƒìƒ‰/ê¹Šì´ ìš°ì„  íƒìƒ‰/ê·¸ë˜í”„ ì´ë¡ /ê·¸ë˜í”„ íƒìƒ‰/êµ¬í˜„/ì‹œë®¬ë ˆì´ì…˜


> **Memory   2060KB                                   Time   84ms                               Code Length   3712B**



{% raw %}
```c++
//1. ëª¨ë“  ë¶€ë¶„ ê²©ìë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
//2. ì´í›„ ì–¼ìŒì´ ìˆëŠ” ì¹¸ 3ê°œ ë˜ëŠ” ê·¸ ì´ìƒê³¼ ì¸ì ‘í•´ìˆì§€ ì•Šì€ ì¹¸ì€ ì–¼ìŒì˜ ì–‘ì´ 1 ì¤„ì–´ë“ ë‹¤

#include<iostream>
#include<cstring>
#include<queue>
using namespace std;


int N, Q;
int iceMap[64][64];
int mapsize;
int schedule[1000];

int TwoN(int num) { // ë©”ëª¨ì´ì œì´ì…˜ í•˜ë©´ ë” ì¢‹ì„ê±°ê°™ê¸´í•¨.

	int result = 1;
	for (int i = 0; i < num; i++) {
		result *= 2;
	}
	return result;
}

void init() {
	cin >> N >> Q;
	mapsize = TwoN(N);
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			cin >> iceMap[i][j];
		}
	}
	for (int i = 0; i < Q; i++) {
		cin >> schedule[i];
	}
}

void Rotate(int y, int x, int size) {
	
	int tmp[64][64] = { 0 }; // ì˜®ê²¨ë‹´ìŒ
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			tmp[i][j] = iceMap[y + i][x + j];
		}
	}

	for (int i = 0; i < size; i++) { // íšŒì „í•œ ë°°ì—´ ì§‘ì–´ë„£ê¸°
		for (int j = 0; j < size; j++) {
			iceMap[y + i][x + j] = tmp[size-1-j][i];
		}
	}

}
void doL(int num) {
	int L = num;
	int TwoL = TwoN(L);

	for (int i = 0; i < mapsize; i += TwoL) {
		for (int j = 0; j < mapsize; j += TwoL) {
			Rotate(i, j, TwoL);
		}
	}
}
void iceMelting() {
	int tmp[64][64] = { 0 };
	
	int dy[] = { 0,1,0,-1 };
	int dx[] = { 1,0,-1,0 };

	memset(tmp, 0, sizeof(tmp));
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			if (iceMap[i][j] == 0) continue; // ë”ì´ìƒ ë…¹ì„ê²Œ ì—†ë‹¤.
			int cnt = 0;
			for (int k = 0; k < 4; k++) {
				int ny = i + dy[k];
				int nx = j + dx[k];
				if (ny >= mapsize || nx >= mapsize || ny < 0 || nx < 0) continue;
				if (iceMap[ny][nx] == 0) continue;
				cnt++;
			}
			if (cnt < 3) {
				tmp[i][j] = iceMap[i][j] - 1;
			}
			else {
				tmp[i][j] = iceMap[i][j];
			}
		}
	}
	memcpy(iceMap, tmp, sizeof(iceMap));
}

void printMap() {
	cout << endl;
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			cout << iceMap[i][j] << " ";
		}
		cout << endl;
	}
}
int sumIce() {
	int result = 0;
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			result += iceMap[i][j];
		}
	}
	return result;
}
int visited[64][64];
int dy[] = { -1,1,0,0 };
int dx[] = { 0,0,-1,1 };
struct loc{
	int y, x;
};

int cntNum(int y ,int x) {
	queue<loc> q;
	q.push({ y,x });
	int result = 1;


	while (!q.empty()) {
		loc now = q.front(); q.pop();
		for (int i = 0; i < 4; i++) {
			int ny = now.y + dy[i];
			int nx = now.x + dx[i];
			if (ny >= mapsize || nx >= mapsize || ny < 0 || nx < 0) continue;
			if (iceMap[ny][nx] == 0) continue; // ì–¼ìŒ ì´ì—†ë‹¤ë©´ ì•ˆê°
			if (visited[ny][nx] == 1) continue; // ë°©ë¬¸ í•œê³³ì´ë¼ë©´ ì•ˆê°
			visited[ny][nx] = 1;
			result++; // íšŸìˆ˜ ì¦ê°€
			q.push({ ny,nx });
		}
	}

	return result;
}

int getBiGBolck() {
	int result = 0;
	memset(visited, 0, sizeof(visited));

	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			if (visited[i][j] == 1) continue;
			if (iceMap[i][j] > 0) {
				visited[i][j] = 1;
				int nowcnt = cntNum(i, j);
				if (nowcnt > result) { // ê°€ì¥ í° ë©ì–´ë¦¬ ì°¾ê¸°
					result = nowcnt;
				}
			}
		}
	}
	return result;
}
int main() {
	init();
	for (int i = 0; i < Q; i++) {
		int now = schedule[i];
		//1. ëª¨ë“  ë¶€ë¶„ ê²©ìë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
		if (now != 0) doL(now);
		//cout << endl << "after rotate : "<< now << endl;
		//printMap();
		//2. ì´í›„ ì–¼ìŒì´ ìˆëŠ” ì¹¸ 3ê°œ ë˜ëŠ” ê·¸ ì´ìƒê³¼ ì¸ì ‘í•´ìˆì§€ ì•Šì€ ì¹¸ì€ ì–¼ìŒì˜ ì–‘ì´ 1 ì¤„ì–´ë“ ë‹¤
		iceMelting();
		//cout << endl<< "after melting" << endl;
		//printMap();
	}
	cout << sumIce() << endl;
	cout << getBiGBolck() << endl;



}
```
{% endraw %}



ëª¨ë“  ë¶€ë¶„ ê²©ìë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•œë‹¤.

ì£¼ì–´ì§„ ì–¼ìŒ ì§€ë„ì—ì„œ, ì–¼ìŒì´ ìˆëŠ” ì¹¸ ì¤‘ 3ê°œ ë˜ëŠ” ê·¸ ì´ìƒê³¼ ì¸ì ‘í•˜ì§€ ì•Šì€ ì¹¸ì€ ì–¼ìŒì˜ ì–‘ì„ 1 ì¤„ì¸ë‹¤.

ì…ë ¥ì„ ë°›ê³ , ì£¼ì–´ì§„ ì¼ì •ëŒ€ë¡œ ê²©ìë¥¼ íšŒì „í•˜ê³  ì–¼ìŒì„ ë…¹ì¸ë‹¤.

ìµœì¢…ì ìœ¼ë¡œ ì–¼ìŒì˜ í•©ê³¼ ê°€ì¥ í° ë©ì–´ë¦¬ì˜ í¬ê¸°ë¥¼ ì¶œë ¥í•œë‹¤.


---


ì´ ë¬¸ì œì—ì„œ ì‹¤ìˆ˜í–ˆë˜ 2ê°€ì§€ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

1. L=1, L=2 ê·¸ë¦¼ì´ ì´ì–´ì§€ëŠ” ì¤„ ì•Œê³  L=1ì—ì„œ L=2ë¡œ ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í–ˆë‹¤ëŠ” ê²ƒì´ë‹¤. ê·¸ê²ƒ ë•Œë¬¸ì— êµ¬í˜„ë„ í›¨ì”¬ ì–´ë ¤ì›Œì§€ê³  ë¨¸ë¦¬ë³µì¡í–ˆëŠ”ë° L=1ê³¼ L=2ëŠ” ë³„ê°œì˜€ë‹¤.. í‚¹..
2. ê°€ì¥ í° ë©ì–´ë¦¬ê°€ ì°¨ì§€í•˜ëŠ” ì¹¸ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•˜ë¼ëŠ” ë¶€ë¶„ì—ì„œ ë‹¹ì—°íˆ ê°€ì¥ í° ë©ì–´ë¦¬ê°€ ê°€ì¥ ì–¼ìŒì˜ ì–‘ì´ ë§ì€ ë©ì–´ë¦¬ë¥¼ ì˜ë¯¸í•˜ëŠ” ì¤„ ì•Œì•˜ë‹¤. ì´ê±´ ë¬¸ì œì—ì„œ ì¶©ë¶„í•œ ì˜¤í•´ì˜ ì†Œì§€ê°€ ìˆë‹¤..

ê³ ì¹˜ê¸° ì „ì˜ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.



{% raw %}
```c++
//1. ëª¨ë“  ë¶€ë¶„ ê²©ìë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
//2. ì´í›„ ì–¼ìŒì´ ìˆëŠ” ì¹¸ 3ê°œ ë˜ëŠ” ê·¸ ì´ìƒê³¼ ì¸ì ‘í•´ìˆì§€ ì•Šì€ ì¹¸ì€ ì–¼ìŒì˜ ì–‘ì´ 1 ì¤„ì–´ë“ ë‹¤

#include<iostream>
#include<cstring>
#include<queue>
using namespace std;


int N, Q;
int iceMap[64][64];
int mapsize;
int schedule[1000];

int TwoN(int num) { // ë©”ëª¨ì´ì œì´ì…˜ í•˜ë©´ ë” ì¢‹ì„ê±°ê°™ê¸´í•¨.

	int result = 1;
	for (int i = 0; i < num; i++) {
		result *= 2;
	}
	return result;
}

void init() {
	cin >> N >> Q;
	mapsize = TwoN(N);
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			cin >> iceMap[i][j];
		}
	}
	for (int i = 0; i < Q; i++) {
		cin >> schedule[i];
	}
}

void Rotate(int y, int x, int size) {
	
	int tmp[64][64] = { 0 }; // ì˜®ê²¨ë‹´ìŒ
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			tmp[i][j] = iceMap[y + i][x + j];
		}
	}

	for (int i = 0; i < size; i++) { // íšŒì „í•œ ë°°ì—´ ì§‘ì–´ë„£ê¸°
		for (int j = 0; j < size; j++) {
			iceMap[y + i][x + j] = tmp[size-1-j][i];
		}
	}

}
void doL(int num) {
	int L = num;
	int TwoL = TwoN(L);

	for (int i = 0; i < mapsize; i += TwoL) {
		for (int j = 0; j < mapsize; j += TwoL) {
			Rotate(i, j, TwoL);
		}
	}
}
void iceMelting() {
	int tmp[64][64] = { 0 };
	
	int dy[] = { 0,1,0,-1 };
	int dx[] = { 1,0,-1,0 };

	memset(tmp, 0, sizeof(tmp));
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			if (iceMap[i][j] == 0) continue; // ë”ì´ìƒ ë…¹ì„ê²Œ ì—†ë‹¤.
			int cnt = 0;
			for (int k = 0; k < 4; k++) {
				int ny = i + dy[k];
				int nx = j + dx[k];
				if (ny >= mapsize || nx >= mapsize || ny < 0 || nx < 0) continue;
				if (iceMap[ny][nx] == 0) continue;
				cnt++;
			}
			if (cnt < 3) {
				tmp[i][j] = iceMap[i][j] - 1;
			}
			else {
				tmp[i][j] = iceMap[i][j];
			}
		}
	}
	memcpy(iceMap, tmp, sizeof(iceMap));
}

void printMap() {
	cout << endl;
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			cout << iceMap[i][j] << " ";
		}
		cout << endl;
	}
}
int sumIce() {
	int result = 0;
	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			result += iceMap[i][j];
		}
	}
	return result;
}
int visited[64][64];
int dy[] = { -1,1,0,0 };
int dx[] = { 0,0,-1,1 };
struct loc{
	int y, x;
};
struct info {
	int cnt, size;
};
info cntNum(int y ,int x) {
	queue<loc> q;
	q.push({ y,x });
	info result = {1,iceMap[y][x]};


	while (!q.empty()) {
		loc now = q.front(); q.pop();
		for (int i = 0; i < 4; i++) {
			int ny = now.y + dy[i];
			int nx = now.x + dx[i];
			if (ny >= mapsize || nx >= mapsize || ny < 0 || nx < 0) continue;
			if (iceMap[ny][nx] == 0) continue; // ì–¼ìŒ ì´ì—†ë‹¤ë©´ ì•ˆê°
			if (visited[ny][nx] == 1) continue; // ë°©ë¬¸ í•œê³³ì´ë¼ë©´ ì•ˆê°
			visited[ny][nx] = 1;
			result.cnt++; // íšŸìˆ˜ ì¦ê°€
			result.size += iceMap[ny][nx]; // í¬ê¸° ì¦ê°€
			q.push({ ny,nx });
		}
	}

	return result;
}

int getBiGBolck() {
	int result = 0;
	int maxsize = 0;
	memset(visited, 0, sizeof(visited));

	for (int i = 0; i < mapsize; i++) {
		for (int j = 0; j < mapsize; j++) {
			if (visited[i][j] == 1) continue;
			if (iceMap[i][j] > 0) {
				visited[i][j] = 1;
				info now = cntNum(i, j);
				//if (now.cnt == 1) continue; // ë©ì–´ë¦¬ê°€ ì•„ë‹˜.
				if (now.size > maxsize) { // ê°€ì¥ í° ë©ì–´ë¦¬ ì°¾ê¸°
					maxsize = now.size;
					result = now.cnt;
				}
			}
		}
	}
	return result;
}
int main() {
	init();
	for (int i = 0; i < Q; i++) {
		int now = schedule[i];
		//1. ëª¨ë“  ë¶€ë¶„ ê²©ìë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
		if (now != 0) doL(now);
		//cout << endl << "after rotate : "<< now << endl;
		//printMap();
		//2. ì´í›„ ì–¼ìŒì´ ìˆëŠ” ì¹¸ 3ê°œ ë˜ëŠ” ê·¸ ì´ìƒê³¼ ì¸ì ‘í•´ìˆì§€ ì•Šì€ ì¹¸ì€ ì–¼ìŒì˜ ì–‘ì´ 1 ì¤„ì–´ë“ ë‹¤
		iceMelting();
		//cout << endl<< "after melting" << endl;
		//printMap();
	}
	cout << sumIce() << endl;
	cout << getBiGBolck() << endl;



}
```
{% endraw %}



ì•ìœ¼ë¡œ ë¬¸ì œë¥¼ ê¼¼ê¼¼íˆ ì½ê³  ì‹¤ìˆ˜ë¥¼ ë” ì¤„ì—¬ë‚˜ê°€ì•¼ í•  ê±° ê°™ë‹¤.


í‚¹ ë°›ëŠ” ë¬¸ì œ ì„¤ëª…..


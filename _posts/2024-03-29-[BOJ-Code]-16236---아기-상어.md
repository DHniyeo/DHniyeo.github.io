---
layout: post
date: 2024-03-29
title: "[BOJ-Code] 16236 - ì•„ê¸° ìƒì–´"
tags: [Algorithm-êµ¬í˜„, Algorithm-DFS/BFS, Samsung-Coding, ]
categories: [CodingTest, Samsungê¸°ì¶œ, ]
---

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/16236)


> ğŸ’¡ ë„ˆë¹„ ìš°ì„  íƒìƒ‰/ê·¸ë˜í”„ ì´ë¡ /ê·¸ë˜í”„ íƒìƒ‰/êµ¬í˜„/ì‹œë®¬ë ˆì´ì…˜


> **Memory   2028KB                                   Time   160ms                               Code Length   2526B**



{% raw %}
```c++
#include<iostream>
#include<math.h>
#include<cstring>
#include<queue>
using namespace std;
int N;
int Map[20][20];
struct info {
	int y, x;
};
info baby_shark, target;
int min_dist = 1e9;
int shark_size = 2;
int get_fish = 0;

void init() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> Map[i][j];
			if (Map[i][j] == 9) {
				baby_shark.y = i;
				baby_shark.x = j;
			}
		}
	}
}
int find_dist(int y, int x) { // ìƒì–´ì™€ ë¬¼ê³ ê¸°ì˜ ìµœë‹¨ ê±°ë¦¬ êµ¬í•˜ê¸°.
	// ìƒì–´ê°€ í° ë¬¼ê³ ê¸°ë¥¼ í”¼í•´ì„œ ì´ë™í•˜ëŠ” ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.
	const int dy[] = { 1, 0, -1, 0 };
	const int dx[] = { 0,-1, 0, 1 };
	queue<info> q;
	int visited[20][20];
	memset(visited, 0, sizeof(visited));

	q.push({ baby_shark.y, baby_shark.x });
	visited[baby_shark.y][baby_shark.x] = 1;
	while (!q.empty()) {
		info now = q.front(); q.pop();
		if (now.y == y && now.x == x) { // í•´ë‹¹ ë¬¼ê³ ê¸° ìœ„ì¹˜ì— ë„ë‹¬
			return visited[now.y][now.x] - 1;
		}
		for (int i = 0; i < 4; i++) {
			int ny = now.y + dy[i];
			int nx = now.x + dx[i];
			if (ny >= N || nx >= N || ny < 0 || nx < 0) continue;
			if (visited[ny][nx] != 0) continue;
			if (Map[ny][nx] > shark_size) continue; // í° ë¬¼ê³ ê¸° í”¼í•´ê°€ê¸°
			visited[ny][nx] = visited[now.y][now.x] + 1;
			q.push({ ny,nx });
		}
	}
	return 1e9; // ë„ë‹¬ í•˜ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ ë§¤ìš° í°ê°’ ë°˜í™˜
}

bool findFish() {
	bool flag = false;
	min_dist = 1e9;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (Map[i][j] < shark_size && Map[i][j] > 0 && Map[i][j] != 9) { // ë¬¼ê³ ê¸° í¬ê¸°ê°€ ì‘ê³  ê±°ë¦¬ê°€ ìµœì†Œì¼ë•Œ
				// ìµœë‹¨ ê±°ë¦¬ êµ¬í•˜ê¸°.
				int dist = find_dist(i, j);
				if (min_dist > dist) {
					flag = true;
					min_dist = dist;
					target.y = i;
					target.x = j;
				}
			}
		}
	}
	return flag;
}
void eat_fish() {
	Map[baby_shark.y][baby_shark.x] = 0; // í˜„ì¬ ìœ„ì¹˜ ë¹„ì›€
	Map[target.y][target.x] = 9; // ë¬¼ê³ ê¸° ìœ„ì¹˜ê°€ ìƒì–´ ìœ„ì¹˜ê°€ë¨.
	baby_shark.y = target.y;
	baby_shark.x = target.x;
	get_fish++; // ë¨¹ì€ ë¬¼ê³ ê¸° ìˆ˜ ì¦ê°€
	if (get_fish == shark_size) { // ìƒì–´ê°€ ë¨¹ì€ ë¬¼ê³ ê¸°ê°€ ì¡°ê±´ì— ë¶€í•©í•  ì‹œ í¬ê¸° ì„±ì¥.
		shark_size++;
		get_fish = 0;
	}
}
void printmap() { // ë””ë²„ê¹…ìš©
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cout << Map[i][j] << " ";
		}
		cout << endl;
	}
}

int main() {
	init();
	int cnt = 0;
	while (1) {
		if (!findFish()) { // ë¬¼ê³ ê¸° ì°¾ê¸°
			break;
		}
		eat_fish();
		cnt += min_dist;
	}
	cout << cnt;
}
```
{% endraw %}



ì´ ì½”ë“œëŠ” N x N í¬ê¸°ì˜ ë§µì—ì„œ ìƒì–´ê°€ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ì°¾ì•„ ë¨¹ëŠ” í”„ë¡œê·¸ë¨ì´ë‹¤.

init í•¨ìˆ˜ì—ì„œ ë§µì„ ì´ˆê¸°í™”í•˜ê³  ìƒì–´ì˜ ìœ„ì¹˜ë¥¼ ì°¾ëŠ”ë‹¤.

find_dist í•¨ìˆ˜ëŠ” ìƒì–´ì™€ ë¬¼ê³ ê¸° ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

findFish í•¨ìˆ˜ëŠ” ìƒì–´ê°€ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ ìµœë‹¨ ê±°ë¦¬ì— ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ì„ íƒí•œë‹¤.

eat_fish í•¨ìˆ˜ëŠ” ì„ íƒëœ ë¬¼ê³ ê¸°ë¥¼ ë¨¹ëŠ”ë‹¤. ìƒì–´ì˜ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³ , ë¨¹ì€ ë¬¼ê³ ê¸° ìˆ˜ê°€ ìƒì–´ í¬ê¸°ì™€ ê°™ì•„ì§€ë©´ ìƒì–´ í¬ê¸°ë¥¼ í‚¤ìš´ë‹¤.

main í•¨ìˆ˜ì—ì„œëŠ” ë¬¼ê³ ê¸°ë¥¼ ì°¾ì•„ ë¨¹ëŠ” ê³¼ì •ì„ ë°˜ë³µí•˜ë©° ê±¸ë¦° ì‹œê°„ì„ ì¶œë ¥í•œë‹¤.


---



## Behind..


ì²˜ìŒì— ì´ ë¬¸ì œë¥¼ í’€ ë•Œ <u>**ìì‹ ì˜ í¬ê¸°ë³´ë‹¤ í° ë¬¼ê³ ê¸°ê°€ ìˆëŠ” ì¹¸ì€ ì§€ë‚˜ê°ˆ ìˆ˜ ì—†ë‹¤!!**</u> ë¼ëŠ” ì¡°ê±´ì„ ë³´ì§€ ëª»í–ˆê³  ì•„ë˜ì™€ ê°™ì´ ì½”ë”©ì„ í–ˆë‹¤.



{% raw %}
```c++
#include<iostream>
#include<math.h>
using namespace std;
int N;
int Map[20][20];
struct info {
	int y, x;
};
info baby_shark, target;
int min_dist = 1e9;
int shark_size = 2;
int get_fish = 0;

void init() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> Map[i][j];
			if (Map[i][j] == 9) {
				baby_shark.y = i;
				baby_shark.x = j;
			}
		}
	}
}
bool findFish() {
	bool flag = false;
	min_dist = 1e9;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (Map[i][j] < shark_size && Map[i][j] > 0) { // ë¬¼ê³ ê¸° í¬ê¸°ê°€ ì‘ê³  ê±°ë¦¬ê°€ ìµœì†Œì¼ë•Œ
				flag = true;
				int dist = abs(baby_shark.y - i) + abs(baby_shark.x - j);
				if (min_dist > dist) {
					min_dist = dist;
					target.y = i;
					target.x = j;
				}
			}
		}
	}
	return flag;
}
void eat_fish() {
	Map[baby_shark.y][baby_shark.x] = 0; // í˜„ì¬ ìœ„ì¹˜ ë¹„ì›€
	Map[target.y][target.x] = 9; // ë¬¼ê³ ê¸° ìœ„ì¹˜ê°€ ìƒì–´ ìœ„ì¹˜ê°€ë¨.
	baby_shark.y = target.y;
	baby_shark.x = target.x;
	get_fish++; // ë¨¹ì€ ë¬¼ê³ ê¸° ìˆ˜ ì¦ê°€
	if (get_fish == shark_size) { // ìƒì–´ê°€ ë¨¹ì€ ë¬¼ê³ ê¸°ê°€ ì¡°ê±´ì— ë¶€í•©í•  ì‹œ í¬ê¸° ì„±ì¥.
		shark_size++;
		get_fish = 0;
	}
}
void printmap() { // ë””ë²„ê¹…ìš©
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cout << Map[i][j] << " ";
		}
		cout << endl;
	}
}

int main() {
	init();
	int cnt = 0;
	while (1) {
		if (!findFish()) { // ë¬¼ê³ ê¸° ì°¾ê¸°
			break;
		}
		eat_fish();
		cnt += min_dist;
	}
	printf("%d\n", cnt);
}
```
{% endraw %}



<ë°˜ë¡€>



{% raw %}
```c++
6
6 0 6 0 6 1
0 0 0 0 0 2
2 3 4 5 6 6
0 0 0 0 0 2
0 2 0 0 0 0
3 9 3 0 0 1
```
{% endraw %}



ê·¸ë˜ì„œ BFSë¥¼ ì´ìš©í•´ì„œ ê° ìƒì–´ê¹Œì§€ ë„ë‹¬í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì¶”ê°€í•˜ì˜€ë‹¤.



{% raw %}
```c++
#include<iostream>
#include<math.h>
#include<cstring>
#include<queue>
using namespace std;
int N;
int Map[20][20];
struct info {
	int y, x;
};
info baby_shark, target;
int min_dist = 1e9;
int shark_size = 2;
int get_fish = 0;

void init() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> Map[i][j];
			if (Map[i][j] == 9) {
				baby_shark.y = i;
				baby_shark.x = j;
			}
		}
	}
}
int find_dist(int y, int x) { // ìƒì–´ì™€ ë¬¼ê³ ê¸°ì˜ ìµœë‹¨ ê±°ë¦¬ êµ¬í•˜ê¸°.
	// ìƒì–´ê°€ í° ë¬¼ê³ ê¸°ë¥¼ í”¼í•´ì„œ ì´ë™í•˜ëŠ” ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.
	const int dy[] = { 1, 0, -1, 0 };
	const int dx[] = { 0,-1, 0, 1 };
	queue<info> q;
	int visited[20][20];
	memset(visited, 0, sizeof(visited));
	
	q.push({ baby_shark.y, baby_shark.x });
	visited[baby_shark.y][baby_shark.x] = 1;
	while (!q.empty()) {
		info now = q.front(); q.pop();
		if (now.y == y && now.x == x) { // í•´ë‹¹ ë¬¼ê³ ê¸° ìœ„ì¹˜ì— ë„ë‹¬
			return visited[now.y][now.x]-1;
		}
		for (int i = 0; i < 4; i++) {
			int ny = now.y + dy[i];
			int nx = now.x + dx[i];
			if (ny >= N || nx >= N || ny < 0 || nx < 0) continue;
			if (visited[ny][nx] != 0) continue;
			if (Map[ny][nx] > shark_size) continue; // í° ë¬¼ê³ ê¸° í”¼í•´ê°€ê¸°
			visited[ny][nx] = visited[now.y][now.x] + 1;
			q.push({ ny,nx });
		}
	}
	return 1e9; // ë„ë‹¬ í•˜ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ ë§¤ìš° í°ê°’ ë°˜í™˜
}

bool findFish() {
	bool flag = false;
	min_dist = 1e9;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (Map[i][j] < shark_size && Map[i][j] > 0) { // ë¬¼ê³ ê¸° í¬ê¸°ê°€ ì‘ê³  ê±°ë¦¬ê°€ ìµœì†Œì¼ë•Œ
				// ìµœë‹¨ ê±°ë¦¬ êµ¬í•˜ê¸°.
				int dist = find_dist(i, j);
				if (min_dist > dist) {
					flag = true;
					min_dist = dist;
					target.y = i;
					target.x = j;
				}
			}
		}
	}
	return flag;
}
void eat_fish() {
	Map[baby_shark.y][baby_shark.x] = 0; // í˜„ì¬ ìœ„ì¹˜ ë¹„ì›€
	Map[target.y][target.x] = 9; // ë¬¼ê³ ê¸° ìœ„ì¹˜ê°€ ìƒì–´ ìœ„ì¹˜ê°€ë¨.
	baby_shark.y = target.y;
	baby_shark.x = target.x;
	get_fish++; // ë¨¹ì€ ë¬¼ê³ ê¸° ìˆ˜ ì¦ê°€
	if (get_fish == shark_size) { // ìƒì–´ê°€ ë¨¹ì€ ë¬¼ê³ ê¸°ê°€ ì¡°ê±´ì— ë¶€í•©í•  ì‹œ í¬ê¸° ì„±ì¥.
		shark_size++;
		get_fish = 0;
	}
}
void printmap() { // ë””ë²„ê¹…ìš©
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cout << Map[i][j] << " ";
		}
		cout << endl;
	}
}

int main() {
	init();
	int cnt = 0;
	while (1) {
		if (!findFish()) { // ë¬¼ê³ ê¸° ì°¾ê¸°
			break;
		}
		eat_fish();
		cnt += min_dist;
	}
	cout << cnt;
}
```
{% endraw %}



ê²°êµ­ ìµœì¢…ì ìœ¼ë¡œ ìˆ˜ì •í•œ ì½”ë“œê°€ ë§¨ ìœ„ì— ìˆëŠ” ì½”ë“œì´ë‹¤..


ì´ ë¬¸ì œë¥¼ í‘¼ ê²ƒì— ë§Œì¡±ì„ í–ˆì§€ë§Œ


ë‹¤ë¥¸ ì½”ë“œë“¤ì„ í™•ì¸í•´ ë³´ë‹ˆ ì‹œê°„ì„ í›¨ì”¬ ë” ì¤„ì¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ìˆì—ˆë‹¤.


ë°”ë¡œ, ë¬¼ê³ ê¸°ë“¤ì˜ ìœ„ì¹˜ë¥¼ ëª¨ë“  ë°°ì—´ì„ ëŒë©° ì¼ì¼ì´ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ì°¾ì€ í›„ ë¬¼ê³ ê¸°ì™€ ìƒì–´ì˜ ê±°ë¦¬ë¥¼ ê°ê° ì¸¡ì •í•´ ìµœì†Ÿê°’ì„ ì°¾ëŠ” ê²ƒì´ ì•„ë‹Œ, ìƒì–´ì˜ ìœ„ì¹˜ì—ì„œ bfsë¡œ ì£¼ë³€ì„ íƒìƒ‰í•˜ê³ , íƒìƒ‰ëœ ê²ƒì´ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¼ë©´ í•´ë‹¹ ë¬¼ê³ ê¸°ì— ëŒ€í•œ ë°ì´í„°ë¥¼ ì°¾ëŠ” ë°©ë²•ì„ ì“°ë©´ ì¢€ ë” ì‹œê°„ì„ ì¤„ì¼ ìˆ˜ ìˆì—ˆë‹¤.


ì´ë•Œ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ê°€ ì—¬ëŸ¬ ë§ˆë¦¬ë¼ë©´ ë§¨ ìœ„, ê·¸ë¦¬ê³  ë§¨ ì™¼ìª½ì— ìˆëŠ” ë¬¼ê³ ê¸° ìˆœì„œë¡œ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ë¯€ë¡œ, Priority Queueë¥¼ ì´ìš©í•œ BFSë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.



{% raw %}
```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <queue>

using namespace std;

int n;
int map[21][21];
struct Shark {
	int y, x, size;
	int eat; //  ì§€ê¸ˆê¹Œì§€ ë¨¹ì€ ë¬¼ê³ ê¸° ê°œìˆ˜
};
struct Fish {
	int y, x, lev;
};
Shark shark;
int dy[4] = { -1,0,0,1 };
int dx[4] = { 0,-1,1,0 };

struct Compare {
	bool operator() ( Fish f, Fish tar ) {
		if (tar.lev < f.lev) return true;
		else if (tar.lev > f.lev) return false;

		if (tar.y < f.y) return true;
		else if (tar.y > f.y) return false;

		return tar.x < f.x;
	}
};

Fish bfs() {
	Fish f = { -1,-1,-1 };
	priority_queue<Fish, vector<Fish>, Compare> q;
	int visited[21][21] = { 0, };

	q.push({ shark.y, shark.x });
	visited[shark.y][shark.x] = 1;
	while (!q.empty()) {
		Fish now = q.top();
		q.pop();

		if (1 <= map[now.y][now.x] && map[now.y][now.x] < shark.size) return now;

		for (int i = 0; i < 4; i++) {
			int ny = now.y + dy[i];
			int nx = now.x + dx[i];
			if (ny < 0 || ny >= n || nx < 0 || nx >= n) continue;
			if (visited[ny][nx] || map[ny][nx] > shark.size) continue;

			q.push({ ny,nx,now.lev + 1 });
			visited[ny][nx] = 1;
		}
	}
	return f;
}

int solve() {
	int t = 0;
	while (1) {
		// 1. bfs 
		Fish ret = bfs();
		if (ret.y == -1) return t;

		// 2. ë¬¼ê³ ê¸° ë¨¹ê¸°
		map[ret.y][ret.x] = 0;
		shark.y = ret.y, shark.x = ret.x;
		if (++shark.eat == shark.size) {
			shark.size++;
			shark.eat = 0;
		}
		t += ret.lev;
	}
	return t;
}

int main() {
	//freopen("input.txt", "r", stdin);

	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> map[i][j];
			if (map[i][j] == 9) { 
				map[i][j] = 0;
				shark = { i,j,2,0 }; 
			}
		}
	}

	int ans = solve();
	printf("%d\n", ans);

	return 0;
}
```
{% endraw %}


